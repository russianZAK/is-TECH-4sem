# Lab-1

## Изучение синтаксиса языка Java и нового окружения.

В рамках лабораторной следует переписать [лабораторную работу №4](https://ronimizy.notion.site/Labs-7375b5d241c347d18616deaeeee2bc48) из прошлого семестра. 

Необходимо использовать [Javadoc](https://www.baeldung.com/javadoc) и сгенерировать html-документацию.

Фреймворк для тестирования рекомендуется [JUnit](https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api).

Система сборки предоставляется на выбор студента: Gradle/Maven.

 В отличии от последующих, эта лабораторная заливается отдельным проектом (**??**)
 
 ---
 
 # Lab-2
 
## Подготовка базы данных.
 
Необходимо создать таблицы БД по примерам, указанным в [приложении А](#Приложение-А). Вариант выбирайте, беря по модулю 4 свою фамилию в списке группы. 

СУБД можно выбрать любую.

Нужно подготовить скрипт DDL, который описывает создание базы данных и таблиц, используемых в этой лабораторной.

## JDBC

Реализовать подключение к БД посредством JDBC (Java DataBase Connectivity). 

Согласно интерфейсу, реализовать методы ниже для обеих таблиц базы данных (где T – это имя вашей сущности): 

```
public T save(T entity);
public void deleteById(long id);
public void deleteByEntity(T entity);
public void deleteAll();
public T update(T entity);
public T getById(long id);
public List<T> getAll();
```

Также необходимо реализовать метод, который возвращает все дочерние сущности по идентификатору родительской:

```
public List<T> getAllByVId(); // Здесь T – это дочерняя сущность, V – родительская.
```

## Hibernate

Реализовать подключение к БД посредством Hibernate - популярное ORM – решение для Java. 

Согласно интерфейсу, реализовать методы ниже для обеих таблиц базы данных (где T – это имя вашей сущности): 

```
public T save(T entity);
public void deleteById(long id);
public void deleteByEntity(T entity);
public void deleteAll();
public T update(T entity);
public T getById(long id);
public List<T> getAll();
```

Также необходимо реализовать метод, который возвращает все дочерние сущности по идентификатору родительской:
```
public List<T> getAllByVId();	// Здесь T – это дочерняя сущность, V – родительская.
```

## MyBatis

Реализовать подключение к БД посредством MyBatis – Java фреймворк для работы с сущностями БД. 

Согласно интерфейсу, реализовать методы ниже для обеих таблиц базы данных (где T – это имя вашей сущности): 

```
public T save(T entity);
public void deleteById(long id);
public void deleteByEntity(T entity);
public void deleteAll();
public T update(T entity);
public T getById(long id);
public List<T> getAll();
```

Также необходимо реализовать метод, который возвращает все дочерние сущности по идентификатору родительской:

```
public List<T> getAllByVId();		// Здесь T – это дочерняя сущность, V – родительская.
```

Для последнего метода необходимо описать условие: если дочерних сущностей больше 5, то нужно вернуть первые 5.

## Сравнение

Необходимо отправить в бд запрос на добавление 100 сущностей и сравнить время, за которое это будет выполнено всеми тремя способами. Затем отправить запрос на получение этих же самых 100 сущностей, (можно использовать метод getAll()), и также сравнить время, за которое это будет сделано тремя различными способами.


## Приложение А

Ниже представлены названия таблиц для БД с атрибутами каждой таблицы (название, тип данных).

### Вариант 0.

*Хозяин*

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Имя           | Varchar         |
| Дата рождения | Date            |

*Котик*

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Имя           | Varchar         |
| Дата рождения | Date            |
| Порода        | Varchar         |
| Цвет          | Varchar         |
| Владелец      | Long            |

- В таблице «Котик» атрибут «Хозяин» является вторичным ключом для атрибута «Идентификатор» из таблицы «Хозяин»;
- Атрибуты «Идентификатор» в обеих таблицах должны быть первичными ключами;
- Атрибут «Цвет» таблицы «Котик» должен представлять из себя ограниченное количество значений: белый, рыжий, коричневый, серый, черный.

### Вариант 1.

*Улица*

| Название поля   | Тип данных поля |
|-----------------|-----------------|
| Идентификатор   | Long            |
| Название        | Varchar         |
| Почтовый индекс | Int             |

*Дом*

| Название поля     | Тип данных поля |
|-------------------|-----------------|
| Идентификатор     | Long            |
| Название          | Varchar         |
| Дата постройки    | Date            |
| Количество этажей | Int             |
| Тип здания        | Varchar         |
| Улица             | Long            |

- В таблице «Дом» атрибут «Улица» является вторичным ключом для атрибута «Идентификатор» из таблицы «Улица»;
- Атрибуты «Идентификатор» в обеих таблицах должны быть первичными ключами;
- Атрибут «Тип здания» таблицы «Дом» должен представлять из себя ограниченное количество значений: жилой помещение, коммерческое помещение, гараж, подсобное помещение.


### Вариант 2.
*Марка автомобиля*

| Название поля  | Тип данных поля |
|----------------|-----------------|
| Идентификатор  | Long            |
| Название       | Varchar         |
| Дата основания | Date            |

*Модель автомобиля*

| Название поля    | Тип данных поля |
|------------------|-----------------|
| Идентификатор    | Long            |
| Название         | Varchar         |
| Длина            | Int             |
| Ширина           | Int             |
| Тип кузова       | Varchar         |
| Марка автомобиля | Long            |

- В таблице «Модель автомобиля» атрибут «Марка автомобиля» является вторичным ключом для атрибута «Идентификатор» из таблицы «Марка автомобиля»;
- Атрибуты «Идентификатор» в обеих таблицах должны быть первичными ключами;
- Атрибут «Тип кузова» таблицы «Модель автомобиля» должен представлять из себя ограниченное количество значений: седан, хэтчбек, универсал, купе, пикап, родстер.

### Вариант 3.

*Сотрудник*

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Имя           | Varchar         |
| Дата рождения | Int             |

*Задача*

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Название      | Varchar         |
| Дедлайн       | Date            |
| Описание      | Int             |
| Тип задачи    | Varchar         |
| Человек       | Long            |



- В таблице «Задача» атрибут «Сотрудник» является вторичным ключом для атрибута «Идентификатор» из таблицы «Сотрудник»;
- Атрибуты «Идентификатор» в обеих таблицах должны быть первичными ключами;
- Атрибут «Тип задачи» таблицы «Задача» должен представлять из себя ограниченное количество значений: новый функционал, ошибка, - улучшение, аналитика.


---
 
 # Lab-3
 **Все задания данной лабораторной выполняются на основе уже сделанной вами лабораторной №2.**


## Миграции.
Необходимо реализовать изменение схемы базы данных посредством миграций с помощью системы миграции Flyway.
Необходимо создать два скрипта миграции: 
- Первым будет являться ваш скрипт создания схемы базы данных из лабораторной №2
- Вторым изменения, которые нужно будет внести в схему, указанные в приложении А данной лабораторной.

**Важно!**

Ваши миграции должны отрабатывать, как на базе данных, в которой нет нужных вам таблиц и прочих объектов БД, так и на базе данных, в которых уже все данные есть.

## Spring Data

> **1.** Подключить к проекту Spring Data.

> **2.** Создать для уже существующих сущностей, (используемых для Hibernate), репозитории.Пример:
> ```
> public interface CarBrandRepository extends JpaRepository<Long, CarBrand> { }
> ```

> **3.** Необходимо реализовать метод, который возвращает все дочерние сущности по идентификатору родительской:
> ```
> public List<T> getAllByVId(id); // Здесь T – это дочерняя сущность, V – родительская.
> ```

> **4)** Необходимо реализовать метод, который возвращает родительские сущности по определенному значению:
> ```
> public List<T> getAllByName(name); // Здесь T – это тип сущности.
> ``` 

## Spring MVC


> **1.** Подключить к проекту Spring MVC.

> **2.** Реализовать CRUD для каждой сущности, к которому можно обратиться через HTTP. (Чтобы было проще и понятнее, почитайте про @Controller и @RestController – это аннотации Spring, позволяющие создавать объекты прослушивающие HTTP – запросы).

> **3.** Для всех созданных классов – контроллеров сделать интерфейс - Swagger.

## Приложение А.

Ниже представлены названия таблиц для БД с атрибутами каждой таблицы (название, тип данных). Зеленым помечены изменения, для которых необходимо сделать миграцию.

## Вариант 1.

### Хозяин

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Имя           | Varchar         |
| Дата рождения | Date            |


### Котик

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Имя           | Varchar         |
| Дата рождения | Date            |
| Порода        | Varchar         |
| Цвет          | Varchar         |
| $${\color{green}Длина \spaceхвоста}$$  | $${\color{green} Int}$$          |
| Владелец      | Long            |


### Блоха

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Имя           | Varchar         |
| Котик         | Long            |

- В таблице «Котик» атрибут «Хозяин» является вторичным ключом для атрибута «Идентификатор» из таблицы «Хозяин»;
- Атрибуты «Идентификатор» в обеих таблицах должны быть первичными ключами;
- Атрибут «Цвет» таблицы «Котик» должен представлять из себя ограниченное количество значений: белый, рыжий, коричневый, серый, черный.

## Вариант 2.

### Улица

| Название поля   | Тип данных поля |
|-----------------|-----------------|
| Идентификатор   | Long            |
| Название        | Varchar         |
| Почтовый индекс | Int             |

### Дом

| Название поля     | Тип данных поля |
|-------------------|-----------------|
| Идентификатор     | Long            |
| Название          | Varchar         |
| Дата постройки    | Date            |
| Количество этажей | Int             |
| Тип здания        | Varchar         |
| $${\color{green}Материал}$$  | $${\color{green} Varchar}$$        |
| Улица             | Long            |


### Квартира

| Название поля     | Тип данных поля |
|-------------------|-----------------|
| Идентификатор     | Long            |
| Номер             | Int             |
| Площадь           | Int             |
| Количество комнат | Int             |
| Дом               | Long            |

- В таблице «Дом» атрибут «Улица» является вторичным ключом для атрибута «Идентификатор» из таблицы «Улица»;
- Атрибуты «Идентификатор» в обеих таблицах должны быть первичными ключами;
- Атрибут «Тип здания» таблицы «Дом» должен представлять из себя ограниченное количество значений: жилой помещение, коммерческое помещение, гараж, подсобное помещение.

## Вариант 3.

### Марка автомобиля

| Название поля  | Тип данных поля |
|----------------|-----------------|
| Идентификатор  | Long            |
| Название       | Varchar         |
| Дата основания | Date            |

### Модель автомобиля

| Название поля    | Тип данных поля |
|------------------|-----------------|
| Идентификатор    | Long            |
| Название         | Varchar         |
| Длина            | Int             |
| Ширина           | Int             |
| $${\color{green}Высота}$$  | $${\color{green} Int}$$                  |
| Тип кузова       | Varchar         |
| Марка автомобиля | Long            |

### Двигатель

| Название поля        | Тип данных поля |
|----------------------|-----------------|
| Идентификатор        | Long            |
| Название             | Varchar         |
| Объем                | Int             |
| Количество цилиндров | Int             |
| Высота               | Int             |
| Модель автомобиля    | Long            |

- В таблице «Модель автомобиля» атрибут «Марка автомобиля» является вторичным ключом для атрибута «Идентификатор» из таблицы «Марка автомобиля»;
- Атрибуты «Идентификатор» в обеих таблицах должны быть первичными ключами;
- Атрибут «Тип кузова» таблицы «Модель автомобиля» должен представлять из себя ограниченное количество значений: седан, хэтчбек, универсал, купе, пикап, родстер.

## Вариант 4.

### Сотрудник

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Имя           | Varchar         |
| Дата рождения | Int             |

### Задача

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Название      | Varchar         |
| Дедлайн       | Date            |
| Описание      | Int             |
| Тип задачи    | Varchar         |
| $${\color{green}Автор}$$  | $${\color{green} Varchar}$$               |
| Человек       | Long            |

### Комментарий

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Содержимое    | Varchar         |
| Автор         | Varchar         |
| Дата создания | Date            |
| Задача        | Long            |

- В таблице «Задача» атрибут «Сотрудник» является вторичным ключом для атрибута «Идентификатор» из таблицы «Сотрудник»;
- Атрибуты «Идентификатор» в обеих таблицах должны быть первичными ключами;
- Атрибут «Тип задачи» таблицы «Задача» должен представлять из себя ограниченное количество значений: новый функционал, ошибка, улучшение, аналитика.

--- 
 
# Lab-4

!!!!!!!!!! disclaimer::::: везде где используются слова *котики, владельцы и тд* вставьте то, что в вашем варианте :)

## Владельцы недовольны, что инфрмацию о котиках может получить кто угодно. В этой лабораторной мы добавим авторизацию к сервису.

Добавляется роль администратора. Он имеет доступ ко всем методам и может создавать новых пользователей. Пользователь связан с владельцем в соотношении 1:1.

Методы по получению информации и котиках и владельцах должны быть защищены [Spring Security](https://docs.spring.io/spring-security/reference/index.html). Доступ к соотвутсвующим endpoint’ам имеют только владельцы котиков и администраторы. Доступ к методам для фильтрации имеют все авторизованные пользователи, но на выходе получают только данные о своих котиках.

**Внимание**: эндпоинты, созданные на предыдущем этапе, не должны быть удалены.

---
 
# Lab-5

## Бизнес прочитал статью о том, что микросервисы это круто и попросил нас разбить программу на микросервисы.

Из созданного приложения выделяются три микросервиса:
- Микросервис доступа к котикам.
- Микросервис доступа к владельцам.
- Микросервис с внешними интерфейсами.

Все они являются **разными приложениями**.

Все созданные ранее эндпоинты и авторизация переезжает на третий микросервис.

Общение между микросервисами происходит посредством [RabbitMQ](https://www.rabbitmq.com/)/[Kafka](https://kafka.apache.org/) (на выбор студента).

Сервисы доступа к котикам и доступа к владельцам могут либо быть подключены к одной БД, либо иметь разные БД. Во втором случае недопустимо делать один запрос на получение данных из двух БД, запроса должно быть два (по одному в каждую).

**Внимание**: недопустимо передавать через RabbitMQ/Kafka JPA сущности. Рекомендуется создать отдельные оберточные классы.

Рекомендуется выделить модуль с JPA сущностями в отдельный подключаемый модуль.





